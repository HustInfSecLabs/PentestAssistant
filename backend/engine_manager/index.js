const { HOST, DOCKER_PORT, SSH_PORT, SSH_PASSWORD, SSH_USERNAME, REMOTE_PATH } = require('../config/engine_config');
const Docker = require('dockerode');
const fs = require('fs');
const ssh2 = require('ssh2');
const { Readable } = require('stream');
const path = require('path');

process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

class EngineManager {
  #docker = new Docker({
    protocol: 'https',
    host: HOST,
    port: DOCKER_PORT,
    ca: fs.readFileSync(path.join(__dirname, '../config/docker-ca/ca.pem')),
    cert: fs.readFileSync(path.join(__dirname, '../config/docker-ca/cert.pem')),
    key: fs.readFileSync(path.join(__dirname, '../config/docker-ca/key.pem'))
    // version: 'v1.25' // required when Docker >= v1.13, https://docs.docker.com/engine/api/version-history/
  });

  #sshFileTransfer = async ({ fileContent, fileName, remotePath }) => {
    return new Promise((resolve, reject) => {
      try {
        const conn = new ssh2.Client();
        conn.on('ready', () => {
          conn.sftp((err, sftp) => {
            if (err) throw err;

            const readStream = new Readable();
            readStream.push(fileContent);
            readStream.push(null);
            const writeStream = sftp.createWriteStream(`${remotePath}/${fileName}`);

            writeStream.on('close', () => {
              // console.log('File transferred successfully');
              conn.end();
              resolve();
            });

            readStream.pipe(writeStream);
          });
        });

        conn.connect({
          host: HOST,
          port: SSH_PORT,
          username: SSH_USERNAME,
          password: SSH_PASSWORD
        });
      } catch (err) {
        reject(err);
      }
    });
  };

  /**
   * @description 上传W3AF HTTP报头文件
   * @param {string} fileContent 文件
   * @returns {Promise<String>} OK
   */
  uploadW3afHttpHeaderFile = async (fileContent) => {
    return this.#sshFileTransfer({
      fileContent,
      fileName: 'httpHeaders.txt',
      remotePath: `${REMOTE_PATH}/w3af`
    });
    // return await axios.post(
    //   `${MANAGE_URL}/upload/w3af-http-headers-file`,
    //   { data: fileContent }
    // );
  };

  /**
   * @description 上传ZAProxy脚本文件
   * @param {string} fileContent 文件
   * @param {string} fileName 文件名
   * @returns {Promise<String>} OK
   */
  uploadZAPScriptFile = async (fileContent, fileName) => {
    return this.#sshFileTransfer({
      fileContent,
      fileName,
      remotePath: `${REMOTE_PATH}/zap`
    });
    // return await axios.post(
    //   `${MANAGE_URL}/upload/zaproxy-scripts`,
    //   { fileContent, fileName }
    // );
  };

  /**
   * @description 获得所有容器状态
   * @returns {Promise<Object>} 容器总体状态
   */
  getContainersStatus = async () => {
    return new Promise((resolve, reject) => {
      this.#docker.listContainers({ all: true }, (err, containers) => {
        if (err) {
          // console.log('Error:', err);
          reject(err);
        } else {
          // console.log('Containers:', containers);
          resolve({ containers });
        }
      });
    });
  };

  /**
   * @description 获得容器状态
   * @param containerName
   * @returns {Promise<void>}
   */
  getContainerStatus = async (containerName) => {
    const container = this.#docker.getContainer(containerName);
    return new Promise((resolve, reject) => {
      container.inspect((err, data) => {
        if (err) {
          // console.log('Error:', err);
          reject(err);
        } else {
          resolve(data);
        }
      });
    });
  };

  /**
   * @description 开启容器
   * @param {string} containerName 容器名
   * @returns {Promise<unknown>}
   */
  startContainer = async (containerName) => {
    const container = this.#docker.getContainer(containerName);
    return new Promise((resolve, reject) => {
      container.start((err) => {
        if (err) {
          // console.log('Error:', err);
          reject(err);
        } else {
          // console.log('Container started');
          resolve();
        }
      });
    });
  };

  /**
   * @description 重启容器
   * @param containerName 容器名
   * @returns {Promise<unknown>}
   */
  restartContainer = async (containerName) => {
    const container = this.#docker.getContainer(containerName);
    return new Promise((resolve, reject) => {
      container.restart((err) => {
        if (err) {
          // console.log('Error:', err);
          reject(err);
        } else {
          // console.log('Container started');
          resolve();
        }
      });
    });
  };

  /**
   * @description 停止容器
   * @param containerName 容器名
   * @returns {Promise<unknown>}
   */
  stopContainer = async (containerName) => {
    const container = this.#docker.getContainer(containerName);
    return new Promise((resolve, reject) => {
      container.stop((err) => {
        if (err) {
          // console.log('Error:', err);
          reject(err);
        } else {
          // console.log('Container started');
          resolve();
        }
      });
    });
  };

  /**
   * @description 删除容器
   * @param containerName 容器名
   * @returns {Promise<unknown>}
   */
  removeContainer = async (containerName) => {
    const container = this.#docker.getContainer(containerName);
    return new Promise((resolve, reject) => {
      container.remove((err) => {
        if (err) {
          // console.log('Error:', err);
          reject(err);
        } else {
          // console.log('Container started');
          resolve();
        }
      });
    });
  };

  /**
   * @description 创建容器
   * @param containerName 容器名
   * @returns {Promise<unknown>}
   */
  runContainer = async (containerName) => {
    let options = {};
    if (containerName === 'zaproxy') {
      options = {
        Image: 'owasp/zap2docker-stable',
        AttachStdin: false,
        AttachStdout: false,
        AttachStderr: false,
        name: 'zaproxy',
        ExposedPorts: {
          '7373/tcp': { }
        },
        HostConfig: {
          PortBindings: {
            '7373/tcp': [{ HostPort: '7373' }]
          },
          Binds: [`${REMOTE_PATH}/zap:/home/zap/exdir`]
        },
        Cmd: [
          'zap.sh',
          '-daemon',
          '-host',
          '0.0.0.0',
          '-port',
          '7373',
          '-config',
          'api.addrs.addr.name=.*',
          '-config',
          'api.addrs.addr.regex=true',
          '-config',
          'api.disablekey=true',
          '-config',
          'start.checkForUpdates=false'
        ]
      };
    } else if (containerName === 'arachni') {
      options = {
        Image: 'arachni/arachni',
        AttachStdin: false,
        AttachStdout: false,
        AttachStderr: false,
        name: 'arachni',
        ExposedPorts: {
          '7331/tcp': { },
          '9292/tcp': { }
        },
        HostConfig: {
          PortBindings: {
            '7331/tcp': [{ HostPort: '7331' }],
            '9292/tcp': [{ HostPort: '9292' }]
          }
        }
      };
    } else if (containerName === 'w3af') {
      options = {
        Image: 'andresriancho/w3af-api',
        AttachStdin: false,
        AttachStdout: false,
        AttachStderr: false,
        name: 'w3af',
        ExposedPorts: {
          '5000/tcp': { }
        },
        HostConfig: {
          PortBindings: {
            '5000/tcp': [{ HostPort: '5000' }]
          },
          Binds: [`${REMOTE_PATH}/w3af:/home/w3af/exdir`]
        }
      };
    } else {
      return;
    }

    return new Promise((resolve, reject) => {
      this.#docker.createContainer(options, (err, container) => {
        if (err) {
          reject(err);
        } else {
          container.start((err) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        }
      });
    });
  };
}

const engineManager = new EngineManager();

const runTest = async () => {
  const res = await engineManager.uploadZAPScriptFile('123OK\n中文\r\n12asdds3sad', 'test.txt');
  // const res = await engineManager.getContainersStatus();
  console.log(res);
};

// runTest();

module.exports = { engineManager };
