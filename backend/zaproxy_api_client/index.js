/**
 * @description ZAP API客户端
 * @type {path.PlatformPath | path}
 */

const axios = require('axios');
const {
  BASE_URL,
  MAX_SCAN_TIME,
  apikey
} = require('./config');

const ZAProxyChecks = require('./zaproxy_checks');

const ContextAction = require('./context_index/action_api');
const AscanAction = require('./ascan_index/action_api');
const AscanView = require('./ascan_index/view_api');
const CoreView = require('./core_index/view_api');
const AlertView = require('./alert_index/view_api');
const SpiderAction = require('./spider_index/action_api');
const SpiderView = require('./spider_index/view_api');
const NetworkAction = require('./network_index/action_api');
const HTTPSessionAction = require('./httpSessions_index/action_api');
const ReplacerAction = require('./replacer_index/action_api');
const ScriptView = require('./script_index/view_api');
const ScriptAction = require('./script_index/action_api');
const ArachniChecks = require('../arachni_api_client/arachni_checks');

class ZAPAPIClient {
  /* 成员变量 */
  /**
   * @description 私有变量profile，用于存储配置的json格式
   */
  #profile = '';

  #scan_time = 0;

  /**
   * @description 私有变量status，用于存储运行状态
   */
  #status = {
    contextId: null, // zaproxy的上下文ID
    contextName: null, // zaproxy的上下文名称
    spiderScanId: null, // zaproxy的Spider扫描ID
    scanScanId: null, // zaproxy的Scan扫描ID
    url: null,
    status: 'Stopped' // zaproxy的扫描状态，Stopped/Spidering/Scanning
  };

  /* 私有成员函数，与W3af引擎API的交互 */
  #getScans = async () => {
    return await axios.get(`${BASE_URL}/scans`);
  };

  #getScanStatus = async (scanId) => {
    const ascanV = new AscanView();
    return ascanV.getAscanStatus(scanId);
  };

  #getScanUrls = async (scanId) => {
    const spiderV = new SpiderView();
    return spiderV.getSpiderFullResults(scanId);
  };

  #getScanVulns = async (scanId) => {
    const scanV = new AscanView();
    return scanV.getScanAlerts(scanId);
  };

  #startNewScan = async (url, contextId) => {
    const ascanA = new AscanAction();
    return ascanA.startAscan(url, contextId);
  };

  #stopRunningScan = async () => {
    const ascanA = new AscanAction();
    return ascanA.stopAllAscan();
  };

  #deleteScan = async (scanId) => {
    const ascanA = new AscanAction();
    return ascanA.removeAscan(scanId);
  };

  #removeAllScan = async () => {
    const ascanA = new AscanAction();
    return ascanA.removeAllAscan();
  };

  #newContext = async (contextName) => {
    const contextA = new ContextAction();
    return contextA.createNewContext(contextName);
  };

  #includeInContext = async (contextName, url) => {
    const contextA = new ContextAction();
    return contextA.setIncludeInContext(contextName, `^${url}.*$`);
  };

  #startNewSpiderScan = async (url, contextName) => {
    const spiderA = new SpiderAction();
    return spiderA.createSpiderScan(url, contextName);
  };

  #getSpiderScanStatus = async (scanId) => {
    const spiderV = new SpiderView();
    const spiderList = await spiderV.getSpiderScans();
    for (const spider of spiderList) {
      if (spider.id === scanId) {
        return spider.state;
      }
    }
    return 'FINISHED';
  };

  #stopRunningSpiderScan = async () => {
    const spiderA = new SpiderAction();
    return spiderA.stopAllSpiderScans();
  };

  #removeAllSpiderScan = async () => {
    const spiderA = new SpiderAction();
    return spiderA.removeAllSpiderScans();
  };

  #getAlertDetails = async (alertId) => {
    const alertV = new AlertView();
    return alertV.getTargetIdAlert(alertId);
  };

  #initSpiderConfig = async () => {
    const spiderA = new SpiderAction();
    await spiderA.setOptionMaxChildren(20);
    await spiderA.setOptionMaxDepth(20);
  };

  #getMessageDetails = async (messageId) => {
    const coreV = new CoreView();
    return coreV.getMessageById(messageId);
  };

  #setConnectionTimeout = async (timeout) => {
    const networkA = new NetworkAction();
    return networkA.setConnectionTimeout(timeout);
  };

  #setHTTPProxy = async (host, port, enabled) => {
    const networkA = new NetworkAction();
    return Promise.all([
      enabled ? networkA.setHttpProxy(host, port) : Promise.resolve(),
      networkA.setHttpProxyEnabled(enabled)
    ]);
  };

  #setScanners = async (scanners) => {
    const ascanA = new AscanAction();
    await ascanA.disableAllScanners();
    return ascanA.enableScanners(scanners.join(','));
  };

  #getScripts = async () => {
    const scriptV = new ScriptView();
    return (await scriptV.listScripts()).data.listScripts;
  };

  #addScript = async (name, type, description) => {
    const scriptA = new ScriptAction();
    const scriptDir = '/home/zap/exdir/';
    return scriptA.loadScript(name, type, 'Oracle Nashorn', scriptDir + name, description);
  };

  #removeScript = async (name) => {
    const scriptA = new ScriptAction();
    return scriptA.removeScript(name);
  };

  #enableScript = async (name) => {
    const scriptA = new ScriptAction();
    return scriptA.enableScript(name);
  };

  #disableScript = async (name) => {
    const scriptA = new ScriptAction();
    return scriptA.disableScript(name);
  };

  // #setHTTPHeaders = async (url, headers) => {
  //   const httpSessionActionA = new HTTPSessionAction();
  //   await httpSessionActionA.createEmptySession(url, 'testSession');
  //   await httpSessionActionA.setActiveSession(url, 'testSession');
  //   await Promise.all(headers.map(header =>
  //     httpSessionActionA.setSessionTokenValue(url, 'testSession', header.name, header.value)
  //   ));
  // };

  #setHTTPHeaders = async (headers) => {
    const replacerA = new ReplacerAction();
    // 删除所有此前添加的替换规则
    for (let i = 0; i > 0; i++) {
      await replacerA.removeReplacerRule(`test_${i}`).catch(() => { i = -1; });
    }
    // 添加新的替换规则
    return await Promise.all(headers.map((header, index) =>
      replacerA.addReplacerRule(`test_${index}`, true, 'REQ_HEADER', false, header.name, header.value)
    ));
  };

  /* 公有成员函数 */
  /**
   * @description 设置配置文件
   * @param url
   * @param profile<Object>
   * @returns Promise<void>
   * 运行过程：首先将传递的参数赋值给私有变量，然后将私有变量写入配置文件
   */
  setProfile = async (url, profile) => {
    // TODO: 生成配置文件（字符串）。有些过于复杂
    // Object.assign(this.#profile, profile);

    // 根据时间生成上下文名字符串
    const contextName = `context_${new Date().getTime()}`;
    // 创建上下文
    this.#status.contextId = await this.#newContext(contextName).then(res => res);
    this.#status.contextName = contextName;
    await this.#includeInContext(this.#status.contextName, url);
    // 设置配置
    let [proxyHost, proxyPort] = ['', ''];
    if (profile.proxy !== '') {
      try {
        const proxyUrl = new URL(profile.proxy.startsWith('http') ? profile.proxy : `http://${profile.proxy}`);
        proxyHost = proxyUrl.hostname;
        proxyPort = proxyUrl.port;
      } catch (e) {
        throw new Error('Invalid proxy URL');
      }
    }

    const httpHeaders = profile.headers.split('\n')
      .filter(header => header.indexOf(':') !== -1)
      .map(header => {
        const [name, value] = header.split(':');
        return {
          name,
          value
        };
      });
    if (profile.auth === 'Basic') {
      const credentials = Buffer.from(`${profile.authUsername}:${profile.authPassword}`).toString('base64');
      const authHeader = `Basic ${credentials}`;
      httpHeaders.push({ name: 'Authorization', value: authHeader });
    }
    const policies = profile.policies.split('|').map(item => item.trim());
    const checks = Array.from(new Set(
      policies.reduce((acc, policy) => {
        if (policy in ZAProxyChecks) { return acc.concat(ZAProxyChecks[policy]); } else { return acc; }
      }, [])
    ));

    await Promise.all([
      this.#initSpiderConfig(),
      /** 扫描参数配置 **/
      this.#setConnectionTimeout(profile.maxResponseTime),
      // 表单认证支持极为有限
      /** HTTP配置 **/
      this.#setHTTPProxy(proxyHost, proxyPort, profile.proxy !== ''),
      httpHeaders.length !== 0 ? this.#setHTTPHeaders(httpHeaders) : Promise.resolve(),
      this.#setScanners(checks)
    ]);
  };

  /**
   * @description 获得运行状态
   * @returns {Promise<{scanId: null}>}
   */
  getStatus = async () => {
    if (this.#status.status === 'Stopped') {
      // 扫描未开始
      return {
        scanId: null
      };
    } else if (this.#status.status === 'Spidering') {
      const urlCount = await this.#getScanUrls(this.#status.spiderScanId).then(res => res.length);
      // URL爬取中，扫描未开始
      const spiderStatus = await this.#getSpiderScanStatus(this.#status.spiderScanId).then(res => res);
      if (spiderStatus === 'FINISHED' || urlCount >= 500 || new Date().getTime() - this.#status.startTime > 18000) {
        // URL爬取结束或达到扫描阈值，扫描开始
        this.#status.scanScanId = await this.#startNewScan(this.#status.url, this.#status.contextId).then(res => res);
        this.#status.status = 'Scanning';
        return {
          scanId: this.#status.scanScanId,
          progress: 0,
          urlCount,
          vulnCount: 0
        };
      } else {
        return {
          scanId: this.#status.spiderScanId,
          progress: 0,
          urlCount,
          vulnCount: 0
        };
      }
    } else {
      // 扫描已开始，状态未知
      const zapStatus = await this.#getScanStatus(this.#status.scanScanId).then(res => res);
      if (zapStatus === '100') {
        // 扫描正好结束
        this.#status.status = 'Stopped';
        return {
          scanId: null
        };
      } else {
        // 扫描仍在运行中
        const [urlCount, vulnCount] = await Promise.all([
          this.#getScanUrls(this.#status.spiderScanId),
          this.#getScanVulns(this.#status.scanScanId)
        ]).then(res => res.map(item => item.length));
        return {
          scanId: this.#status.scanScanId,
          progress: 0,
          urlCount,
          vulnCount
        };
      }
    }
  };

  /**
   * @description 启动扫描
   * @param url<String>
   * @returns {Promise<void>}
   */
  startScan = async (url) => {
    // if (this.#status.status !== 'Stopped') {
    //   throw new Error('ZAProxy扫描正在进行中，无法开启新任务');
    // } else {
    await this.clearScan();
    this.#status.url = url;
    // this.#status.scanId = await this.#startNewScan(url).then(res => res.data.id);
    this.#status.spiderScanId = await this.#startNewSpiderScan(url, this.#status.contextName).then(res => res);
    this.#status.status = 'Spidering';
    this.#scan_time = new Date().getTime();
    return this.#status.spiderScanId;
    // }
  };

  /**
   * @description 停止扫描
   * @returns {Promise<void>}
   */
  stopScan = async () => {
    await this.#stopRunningSpiderScan();
    await this.#stopRunningScan();
    this.#status.status = 'Stopped';
  };

  /**
   * @description 获得实时日志
   * @returns {Promise<string>}
   */
  getLogs = async () => {
    // TODO: 获得实时日志
  };

  /**
   * @description 获得扫描结果
   * @returns {Promise<Object>}
   */
  getResult = async () => {
    const [urlList, vulnList] = await Promise.all([
      this.#getScanUrls(this.#status.spiderScanId),
      this.#getScanVulns(this.#status.scanScanId)
    ]).then(res => res.map(item => item));
    // TODO: 结果太多导致socket hang out

    const urls = urlList
      .filter(item => item.statusCode === '200')
      .map(url => ({
        url: url.url,
        method: url.method,
        postData: '',
        resourceType: 'static'
      }));

    const vulns = [];
    await Promise.all(vulnList.map(vulnId => {
      return new Promise((resolve, reject) => {
        this.#getAlertDetails(vulnId).then(vuln => {
          this.#getMessageDetails(vuln.messageId).then(message => {
            vulns.push({
              cwe: vuln.cweid,
              name: vuln.alert,
              href: vuln.url,
              level: vuln?.risk?.toLowerCase() ?? 'unknown',
              engine: 'zaproxy',
              information: {
                description: vuln?.description,
                evidence: vuln?.evidence,
                attack: vuln?.attack,
                request: ((message?.requestHeader ?? '').trim() + '\n\n' + (message?.requestBody ?? '').trim()).trim(),
                response: ((message?.responseHeader ?? '').trim() + '\n\n' + (message?.responseBody ?? '').trim()).trim()
              }
            });
            resolve();
          }).catch(err => {
            reject(err);
          });
        }).catch(err => {
          reject(err);
        });
      });
    }));

    return {
      urls,
      vulns
    };
  };

  /**
   * @description 初始化API客户端
   * @returns {Promise<void>}
   */
  initClient = async () => {
    // TODO: 初始化API客户端
  };

  /**
   * @description 清除zap扫描记录
   * @returns {Promise<void>}
   */
  clearScan = async () => {
    // 清除Wzap扫描记录
    await this.#removeAllScan();
    await this.#removeAllSpiderScan();
  };

  /**
   * @description 获得脚本列表
   * @returns {Promise<Array>}
   */
  getScripts = async () => {
    return this.#getScripts();
  };

  /**
   * @description 添加脚本
   * @param name<String> 脚本名称
   * @param description<String> 脚本描述
   */
  addScript = async (name, type, description) => {
    return this.#addScript(name, type, description);
  };

  /**
   * @description 删除脚本
   * @param name<String> 脚本名称
   */
  removeScript = async (name) => {
    return this.#removeScript(name);
  };

  /**
   * @description 启用脚本
   * @param name<String> 脚本名称
   */
  enableScript = async (name) => {
    return this.#enableScript(name);
  };

  /**
   * @description 禁用脚本
   * @param name<String> 脚本名称
   */
  disableScript = async (name) => {
    return this.#disableScript(name);
  };
}

const zaproxyAPIClient = new ZAPAPIClient();
module.exports = { zaproxyAPIClient };

const runTest = async () => {
  await zaproxyAPIClient.setProfile({});
  await zaproxyAPIClient.startScan('http://127.0.0.1:11452');
  setInterval(async () => {
    const status = await zaproxyAPIClient.getStatus();
    console.log(status);
  }, 2000);

  setTimeout(async () => {
    await zaproxyAPIClient.stopScan();
    const result = await zaproxyAPIClient.getResult();
    console.log(result);
  }, 200000);
};

// runTest();
