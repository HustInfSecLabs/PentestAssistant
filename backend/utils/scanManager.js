const { Scan, ScanStatus, ScanResult, Vuln } = require('./db');
const { w3afAPIClient } = require('../w3af_api_client');
const { zaproxyAPIClient } = require('../zaproxy_api_client');
const { arachniAPIClient } = require('../arachni_api_client');

// ScanManager类，用于管理W3AF、ZAPROXY、ARACHNI三个扫描工具的扫描生命周期，并和数据库交互更改状态
// TODO: 每次任务开启前先重置引擎状态；变为费时操作，需要引入taskManager

class ScanManager {
  #intervalId = -1;
  #maxScanTime = 600;
  #monitorTimeoutId = -1;
  #lastResultSaveTime = new Date();
  #saveInterval = 1000 * 10; // 10秒保存一次扫描结果

  /**
   * @description: 开始扫描任务
   * @param {String} scanId 扫描任务ID
   * @param {String} target 扫描目标
   * @param {String} profile 扫描配置
   * @return {Promise<void>}
   */
  startScanTask = (scanId) => {
    return Scan.findById(scanId).then(scan => {
      if (!scan) {
        throw new Error('无此ScanID的扫描任务：' + scanId);
      } else if (scan.engineStatus) {
        throw new Error('此ScanID的扫描任务已开启：' + scanId);
      } else {
        const engineStatus = new ScanStatus();

        // 设置待开启的引擎
        scan.profile.engine.w3af ? (engineStatus.w3afStatus.status = 'Stopped') : (engineStatus.w3afStatus.status = 'Unused');
        scan.profile.engine.zaproxy ? (engineStatus.zaproxyStatus.status = 'Stopped') : (engineStatus.zaproxyStatus.status = 'Unused');
        scan.profile.engine.arachni ? (engineStatus.arachniStatus.status = 'Stopped') : (engineStatus.arachniStatus.status = 'Unused');

        scan.engineStatus = engineStatus;
        scan.save();

        // TODO: 配置管理
        this.#maxScanTime = scan.profile.maxScanTime;

        /** 引擎配置管理 **/
        Promise.allSettled([
          engineStatus.w3afStatus.status === 'Stopped'
            ? w3afAPIClient.setProfile(scan.target, scan.profile)
            : Promise.resolve(),
          engineStatus.zaproxyStatus.status === 'Stopped'
            ? zaproxyAPIClient.setProfile(scan.target, scan.profile)
            : Promise.resolve(),
          engineStatus.arachniStatus.status === 'Stopped'
            ? arachniAPIClient.setProfile(scan.profile)
            : Promise.resolve()
        ]).then(res => {
          // 修改状态
          [engineStatus.w3afStatus, engineStatus.zaproxyStatus, engineStatus.arachniStatus]
            .forEach((item, index) => {
              res[index].status === 'rejected' && (
                (item.status = 'Error') && (item.message = res[index]?.reason?.message)
              );
            });

          /** 开启扫描任务 **/
          Promise.allSettled([
            engineStatus.w3afStatus.status === 'Stopped'
              ? w3afAPIClient.startScan(scan.target)
              : Promise.resolve(),
            engineStatus.zaproxyStatus.status === 'Stopped'
              ? zaproxyAPIClient.startScan(scan.target)
              : Promise.resolve(),
            engineStatus.arachniStatus.status === 'Stopped'
              ? arachniAPIClient.startScan(scan.target)
              : Promise.resolve()
          ]).then(res => {
            // 修改状态
            [engineStatus.w3afStatus, engineStatus.zaproxyStatus, engineStatus.arachniStatus]
              .forEach((item, index) => {
                res[index].status === 'rejected'
                  ? (
                      (item.status = 'Error') && (item.message = res[index]?.reason?.message)
                    )
                  : (item.status === 'Stopped' && (
                      (item.status = 'Running') && (item.scanId = res[index].value)
                    ));
              });

            scan.engineStatus = engineStatus;
            scan.save();

            // TODO: 设置定时器，定时获取扫描状态
            this.#lastResultSaveTime = new Date();
            setTimeout(() => {
              this.#setScanTaskStatusTimer(scanId);
            }, 5000);
          });
        });
      }
    });
  };

  /**
   * @description: 停止扫描任务
   * @return {Promise<void>}
   */
  stopScanTask = (scanId, statusString = 'Halted') => {
    return Scan.findById(scanId).then(scan => {
      if (!scan) {
        throw new Error('无此ScanID的扫描任务：' + scanId);
      } else if (scan.status !== 'Running') {
        throw new Error('此ScanID的扫描任务并未运行：' + scanId);
      }
      if (!scan.engineStatus) {
        throw new Error('此ScanID的扫描任务尚未开启：' + scanId);
      } else {
        this.#clearScanTaskStatusTimer();

        const engineStatus = scan.engineStatus;
        /** 引擎配置管理 **/
        Promise.allSettled([
          engineStatus.w3afStatus.status !== 'Stopped'
            ? w3afAPIClient.stopScan()
            : Promise.resolve(),
          engineStatus.zaproxyStatus.status !== 'Stopped'
            ? zaproxyAPIClient.stopScan()
            : Promise.resolve(),
          engineStatus.arachniStatus.status !== 'Stopped'
            ? arachniAPIClient.stopScan()
            : Promise.resolve()
        ]).then(res => {
          // 修改状态
          [engineStatus.w3afStatus, engineStatus.zaproxyStatus, engineStatus.arachniStatus]
            .forEach((item, index) => {
              res[index].status === 'rejected'
                ? item.status = 'Error'
                : item.status === 'Running' && (item.status = statusString);
            });

          scan.engineStatus = engineStatus;
          scan.status = statusString;

          Scan.findOneAndUpdate({ _id: scanId }, { engineStatus, status: statusString }, null, (err, doc) => {
            if (err) {
              console.log('保存扫描结束状态失败：' + err.message);
            }
          });

          // 获取扫描结果
          this.#saveScanTaskResult(scanId);
        });
      }
    });
  };

  /**
   * @description: 获取扫描任务状态
   * @return {Promise<Object>}
   */
  getScanTaskStatus = (scanId) => {
    return Scan.findById(scanId).then(scan => {
      if (!scan) {
        throw new Error('无此ScanID的扫描任务：' + scanId);
      } else if (scan.status !== 'Running') {
        throw new Error('此ScanID的扫描任务并未运行：' + scanId);
      } else {
        // 返回数据库中实时缓存的状态
        const retStatus = {
          status: scan.status,
          progress: 0,
          urlCount: 0,
          vulnCount: 0
        };

        (items => {
          for (const item of items) {
            retStatus.progress += item.progress;
            item.urlCount > retStatus.urlCount && (retStatus.urlCount = item.urlCount);
            item.vulnCount > retStatus.vulnCount && (retStatus.vulnCount = item.vulnCount);
          }
          retStatus.progress = Math.round(retStatus.progress / items.length);
        })(
          [scan.engineStatus.w3afStatus, scan.engineStatus.zaproxyStatus, scan.engineStatus.arachniStatus]
            .filter(item => item.status !== 'Unused')
        );
        return retStatus;
      }
    });
  };

  /**
   * @description: 通过三个引擎的状态确定整体状态
   * @return {string}
   */
  #determineScanStatus = (engineStatus) => {
    // 状态判定：
    // 1. 若三个引擎其中一个状态为Running，则扫描任务为Running
    // 2. 若三个引擎均不为Running，均为Error，则扫描任务为Error
    // 3. 若三个扫描引擎均不为Running且并非均为Error，其中至少有一个为Halted，则扫描任务为Halted
    // 4. 若三个扫描引擎均不为Running且并非均为Error，其中至少有一个为Timeout，则扫描任务为Timeout
    // （理论上Timeout状态和Halted状态不会同时出现）
    // 5. 若三个扫描引擎均只为Error或Stopped，则扫描任务为Stopped
    // 6. 若三个扫描引擎均为Unused，则扫描任务为Stopped（这种情况是否要报错？）

    const statusList = [engineStatus.w3afStatus.status, engineStatus.zaproxyStatus.status, engineStatus.arachniStatus.status];

    return (
      statusList.filter(item => item === 'Running').length > 0
        ? 'Running'
        : statusList.filter(item => item === 'Error').length === 3
          ? 'Error'
          : statusList.filter(item => item === 'Halted').length > 0
            ? 'Halted'
            : statusList.filter(item => item === 'Timeout').length > 0
              ? 'Timeout'
              : 'Stopped'
    );
  };

  /**
   * @description: 获得URL的资源类型
   * @return {string}
   */
  #getResourceType = (obj) => {
    if (obj.method !== 'GET') {
      return 'interface';
    }

    const path = new URL(obj.url).pathname;
    const fileName = path.split('/').pop();
    const fileType = fileName.split('.').pop().toLowerCase();

    switch (fileType) {
      case '':
        return 'webpage';
      case 'html':
      case 'htm':
        return 'html';
      case 'cgi':
        return 'cgi';
      case 'php':
        return 'php';
      case 'asp':
      case 'aspx':
        return 'asp';
      case 'jsp':
        return 'jsp';
      case 'js':
      case 'jsx':
      case 'ts':
        return 'script';
      case 'css':
        return 'stylesheet';
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif':
      case 'bmp':
      case 'ico':
      case 'svg':
        return 'image';
      case 'mp3':
      case 'wav':
      case 'wma':
      case 'ogg':
      case 'ape':
      case 'flac':
        return 'audio';
      case 'mp4':
      case 'avi':
      case 'wmv':
      case 'rmvb':
      case 'rm':
      case 'mkv':
      case 'flv':
      case 'mov':
      case 'mpeg':
        return 'video';
      case 'doc':
      case 'docx':
      case 'xls':
      case 'xlsx':
      case 'ppt':
      case 'pptx':
      case 'pdf':
      case 'txt':
      case 'md':
        return 'document';
      case 'woff':
      case 'woff2':
      case 'ttf':
      case 'otf':
      case 'eot':
        return 'font';
      default:
        return 'unknown';
    }
  };

  /**
   * @description: URL分析和去重
   * @return {Array}
   */
  #analyzeURLs = (urls) => {
    const hash = {};
    return urls.reduce((prev, curr) => {
      const urlID = curr.method + ' ' + curr.url;
      if (!hash[urlID]) {
        hash[urlID] = true;
        curr.resourceType = this.#getResourceType(curr);
        prev.push(curr);
      }
      return prev;
    }, []).sort((a, b) => a.url.localeCompare(b.url));
  };

  /**
   * @description: 漏洞分析和整合
   * @return {Array}
   */
  #analyzeVulns = async (vulns) => {
    const levelCompare = (a, b) => {
      const levelMap = {
        critical: 0,
        high: 1,
        medium: 2,
        low: 3,
        informational: 4,
        unknown: 5
      };
      return levelMap[b] - levelMap[a];
    };

    const hrefMerge = (href) => {
      return Object.values(
        href.reduce((prev, curr) => {
          if (!prev[curr.url]) {
            prev[curr.url] = {
              url: curr.url,
              properties: {
                w3af: {
                  count: 0,
                  information: []
                },
                zaproxy: {
                  count: 0,
                  information: []
                },
                arachni: {
                  count: 0,
                  information: []
                }
              }
            };
          }
          prev[curr.url].properties[curr?.engine].count++;
          prev[curr.url].properties[curr?.engine].information.push(curr.information);
          return prev;
        }, {})).sort((a, b) => a.url.localeCompare(b.url));
    };

    const vulnDict = await vulns.reduce(async (prevAsync, curr) => {
      const prev = await prevAsync;
      const vulnId = curr.cwe ?? curr.name;
      if (!prev[vulnId]) {
        await Vuln.findOne({ cwe: curr.cwe }).then(vuln => {
          if (!vuln) {
            prev[vulnId] = {
              name: curr?.name,
              level: curr?.level,
              cwe: -1,
              description: '暂无此漏洞的描述信息',
              mitigation: [],
              href: []
            };
          } else {
            prev[vulnId] = {
              name: vuln?.name,
              level: vuln?.level,
              cwe: vuln?.cwe,
              description: vuln?.description,
              mitigation: vuln?.mitigation,
              href: []
            };
          }
        });
      }
      // TODO: information优化
      prev[vulnId].href.push({
        url: curr?.href,
        engine: curr?.engine,
        information: curr?.information
      });
      prev[vulnId].level = levelCompare(prev[vulnId].level, curr.level) > 0 ? prev[vulnId].level : curr.level;
      return prev;
    }, {});
    return Object.values(vulnDict).map(item => {
      item.href = hrefMerge(item.href);
      return item;
    });
  };

  /**
   * @description: 过滤警告等级
   */
  #filterVulnLevel = (vulns, level) => {
    const levelMap = {
      critical: 0,
      high: 1,
      medium: 2,
      low: 3,
      informational: 4,
      unknown: 4
    };
    return vulns.filter(vuln => levelMap[vuln.level] <= levelMap[level]);
  };

  /**
   * @description: 保存扫描任务状态
   */
  #saveScanTaskStatus = (scanId) => {
    return Scan.findById(scanId).then(scan => {
      if (!scan) {
        throw new Error('无此ScanID的扫描任务：' + scanId);
      } else {
        const engineStatus = scan.engineStatus;
        /** 引擎配置管理 **/
        return Promise.allSettled([
          engineStatus.w3afStatus.status === 'Running'
            ? w3afAPIClient.getStatus()
            : Promise.resolve({ scanId: null }),
          engineStatus.zaproxyStatus.status === 'Running'
            ? zaproxyAPIClient.getStatus()
            : Promise.resolve({ scanId: null }),
          engineStatus.arachniStatus.status === 'Running'
            ? arachniAPIClient.getStatus()
            : Promise.resolve({ scanId: null })
        ]).then(res => {
          // 修改状态
          [engineStatus.w3afStatus, engineStatus.zaproxyStatus, engineStatus.arachniStatus]
            .forEach((item, index) => {
              res[index].status === 'rejected'
                ? (
                    (item.status = 'Error') && (item.message = res[index]?.reason?.message)
                  )
                : (
                    (item.status !== 'Unused' && res[index].value.scanId === null)
                      ? (item.status = 'Stopped')
                      : Object.assign(item, {
                        progress: res[index].value.progress,
                        urlCount: res[index].value.urlCount,
                        vulnCount: res[index].value.vulnCount
                      })

                  );
            });

          scan.engineStatus = engineStatus;
          scan.status = this.#determineScanStatus(scan.engineStatus);

          Scan.findOneAndUpdate({ _id: scanId }, { engineStatus, status: this.#determineScanStatus(scan.engineStatus) }, null, (err, doc) => {
            if (err) {
              console.log('保存扫描状态失败：' + err.message);
            }
          });

          return scan.status;
        });
      }
    });
  };

  /**
   * @description: 获取扫描任务结果
   */
  #saveScanTaskResult = (scanId) => {
    Scan.findById(scanId).then(scan => {
      if (!scan) {
        throw new Error('无此ScanID的扫描任务：' + scanId);
      } else {
        const engineStatus = scan.engineStatus;
        /** 引擎配置管理 **/
        Promise.allSettled([
          engineStatus.w3afStatus.status !== 'Unused'
            ? w3afAPIClient.getResult()
            : Promise.resolve({ urls: [], vulns: [] }),
          engineStatus.zaproxyStatus.status !== 'Unused'
            ? zaproxyAPIClient.getResult()
            : Promise.resolve({ urls: [], vulns: [] }),
          engineStatus.arachniStatus.status !== 'Unused'
            ? arachniAPIClient.getResult()
            : Promise.resolve({ urls: [], vulns: [] })
        ]).then(res => {
          const result = {
            name: '报告：' + scan.name,
            urls: [],
            vulns: []
          };

          [engineStatus.w3afStatus, engineStatus.zaproxyStatus, engineStatus.arachniStatus]
            .forEach((item, index) => {
              if (res[index].status === 'rejected') {
                (item.status = 'Error') && (item.message = res[index]?.reason?.message);
              } else {
                // TODO: 结果整合为数据库格式
                result.urls = result.urls.concat(res[index].value.urls);
                result.vulns = result.vulns.concat(res[index].value.vulns);
              }
            });

          result.urls = this.#analyzeURLs(result.urls);
          this.#analyzeVulns(result.vulns).then(vulns => {
            /** 漏洞扫描配置 **/
            result.vulns = this.#filterVulnLevel(vulns, scan.profile.warningThreshold);
            if (!scan.result) {
              scan.result = new ScanResult(result);
            } else {
              scan.result.urls = result.urls.length >= scan.result.urls.length ? result.urls : scan.result.urls;
              scan.result.vulns = result.vulns.length >= scan.result.vulns.length ? result.vulns : scan.result.vulns;
            }
            Scan.findOneAndUpdate({ _id: scanId }, { result: scan.result }, null, (err, doc) => {
              if (err) {
                console.log('保存扫描结果失败：' + err.message);
              }
            });
          });
        });
      }
    });
  };

  /**
   * @description: 设置定时器，定时获取扫描任务状态
   */
  #setScanTaskStatusTimer = (scanId) => {
    this.#intervalId = setInterval(() => {
      this.#saveScanTaskStatus(scanId).then(status => {
        if (status !== 'Running') {
          this.#saveScanTaskResult(scanId);
          this.#clearScanTaskStatusTimer();
        } else {
          const nowTime = new Date();
          if (nowTime - this.#lastResultSaveTime > this.#saveInterval) {
            this.#lastResultSaveTime = nowTime;
            this.#saveScanTaskResult(scanId);
          }
        }
      }).catch(err => {
        this.#clearScanTaskStatusTimer();
        console.log(err.message);
      });
    }, 1000);

    /** 扫描参数配置 **/
    this.#monitorTimeoutId = setTimeout(async () => {
      await this.stopScanTask(scanId, 'Timeout');
    }, this.#maxScanTime * 1000);
  };

  /**
   * @description: 清除定时器
   */
  #clearScanTaskStatusTimer = () => {
    if (this.#intervalId !== -1) {
      clearInterval(this.#intervalId);
      this.#intervalId = -1;
    }
    if (this.#monitorTimeoutId !== -1) {
      clearTimeout(this.#monitorTimeoutId);
      this.#monitorTimeoutId = -1;
    }
  };
}

const scanManager = new ScanManager();
module.exports = { scanManager };
