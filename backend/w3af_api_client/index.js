/**
 * @description W3af API客户端
 * @type {path.PlatformPath | path}
 * 负责与W3af引擎的交互，并储存运行状态。
 * 1. 通过setProfile方法设置配置文件
 * 2. 通过getStatus方法获得引擎运行状态
 * 3. 通过startScan方法启动扫描
 * 4. 通过stopScan方法停止扫描
 * 5. 通过getLogs方法获得实时日志
 * 6. 通过getResult方法获得扫描结果
 * 实现方案：
 * (1) API客户端不负责实时监控引擎的运行状态，只在前端发来请求时向W3af请求运行状态，并返回当前运行状态。
 * 设置一次性定时器以在最大运行时间到达时，自动结束扫描。若在请求运行状态时发现扫描已经结束，则清除定时器。
 * 1) 若前端实时监控扫描运行，则后端会根据前端的心跳报文实时更新运行状态。
 * 2) 若前端不实时监控扫描运行，则后端与W3af引擎间仅有定时器的一次性停止扫描而并无其他交互。
 * 优点：资源占用少，逻辑结构清晰。
 * 缺点：无法获得扫描结束时间（除非API提供）、用户请求状态时可能更新慢。
 * (2) API客户端负责心跳报文实时监控运行状态。
 * 设置重复性定时器，在每次请求状态时，检测是否到达最大运行时间，若到达则停止扫描和定时器。
 * 优点：可以获得扫描结束时间、用户请求状态时更新快。
 * 缺点：资源占用多，逻辑结构复杂。
 * TODO: 需要考虑后端重启而W3af扫描仍在进行的情况。
 * 可能需要读取数据库恢复运行状态，但应尽量避免在API客户端模块中直接操作数据库。
 * 可以考虑由管理程序读数据库发现未完成的扫描状态，并对API客户端模块进行初始化。
 * 由此，API客户端可不负责监控运行状态，只负责被调用时与W3af引擎进行交互，将设计方案问题转为调用者处理。
 */

const path = require('path');
const fs = require('fs');
const axios = require('axios');
const { BASE_URL, TARGET_URL, MAX_SCAN_TIME } = require('./config');
const W3afChecks = require('./w3af_checks');
const { engineManager } = require('../engine_manager');

class W3afAPIClient {
  /* 成员变量 */
  /**
   * @description 私有变量profile，用于存储配置的json格式
   */
  #profile = '';

  /**
   * @description 私有变量status，用于存储运行状态
   */
  #status = {
    scanId: -1, // w3af的扫描ID
    status: 'Stopped'
    // createTime: Date.now(), // 扫描的开始时间
    // maxScanTime: MAX_SCAN_TIME // 扫描的最大运行时间，结合开始时间可以计算出扫描的结束时间

    /* 一次性定时器方案 */
    // monitorTimeoutId: -1 // 扫描超时则自动停止扫描的定时器的ID

    /* 重复性定时器方案 */
    // monitorIntervalId: -1, // 监控扫描状态的定时器的ID
    // progress: -1, // 扫描的进度，可能不支持
    // urlCount: -1, // 扫描的URL总数
    // vulnCount: -1 // 扫描的漏洞总数
  };

  /* 私有成员函数，与W3af引擎API的交互 */
  #getScans = async () => {
    return await axios.get(`${BASE_URL}/scans/`);
  };

  #getScanStatus = async (scanId) => {
    return await axios.get(`${BASE_URL}/scans/${scanId}/status`);
  };

  #getScanLog = async (scanId) => {
    return await axios.get(`${BASE_URL}/scans/${scanId}/log/`);
  };

  #getScanUrls = async (scanId) => {
    return await axios.get(`${BASE_URL}/scans/${scanId}/urls/`);
  };

  getScanRequests = async (scanId) => {
    return await axios.get(`${BASE_URL}/scans/${scanId}/fuzzable-requests/`);
  };

  #getScanVulns = async (scanId) => {
    return await axios.get(`${BASE_URL}/scans/${scanId}/kb/`);
  };

  #getScanVulnDetail = async (href) => {
    return await axios.get(`${BASE_URL}${href}`);
  };

  #getScanVulnTrafficDetail = async (href) => {
    return await axios.get(`${BASE_URL}${href}`);
  };

  #startNewScan = async (url, profile) => {
    return await axios.post(`${BASE_URL}/scans/`, {
      target_urls: [url],
      scan_profile: profile
    });
  };

  #stopRunningScan = async (scanId) => {
    return await axios.get(`${BASE_URL}/scans/${scanId}/stop`);
  };

  #deleteScan = async (scanId) => {
    return await axios.delete(`${BASE_URL}/scans/${scanId}`);
  };

  /* 公有成员函数 */
  /**
   * @description 设置配置文件
   * @param profile<Object>
   * @returns Promise<void>
   * 运行过程：首先将传递的参数赋值给私有变量，然后将私有变量写入配置文件
   */
  setProfile = async (url, profile) => {
    await new Promise((resolve, reject) => {
      fs.readFile(path.resolve(__dirname, 'profiles/new.pw3af'), 'utf8', async (err, data) => {
        if (err) {
          reject(err);
        } else {
          if (profile.maxResponseTime) {
            data = data.replace(/max_response_time = 0/g, `max_response_time = ${profile.maxResponseTime * 1000}`);
          }
          if (profile.auth === 'Basic') {
            data = data.replace(/basic_auth_user = /g, `basic_auth_user = ${profile.authUsername}`);
            data = data.replace(/basic_auth_passwd = /g, `basic_auth_passwd = ${profile.authPassword}`);
            data = data.replace(/basic_auth_domain = /g, `basic_auth_domain = ${new URL(url).host}`);
          } else if (profile.auth === 'Digest') {
            // W3AF不支持Digest认证
          } else if (profile.auth === 'NTLM') {
            data = data.replace(/ntlm_auth_user = /g, `ntlm_auth_user = ${profile.authUsername}`);
            data = data.replace(/ntlm_auth_passwd = /g, `ntlm_auth_passwd = ${profile.authPassword}`);
          } else if (profile.auth === 'Form') {
            // w3af对表单登录的支持极其有限
            // data += `[auth.generic]\nusername = ${profile.authUsername}\npassword = ${profile.authPassword}\nusername_field = username\npassword_field = password\n`;
          }
          if (profile.proxy !== '') {
            try {
              const proxyUrl = new URL(profile.proxy.startsWith('http') ? profile.proxy : `http://${profile.proxy}`);
              data = data.replace(/proxy_address = /g, `proxy_address = ${proxyUrl.hostname}`);
              data = data.replace(/proxy_port = 8080/g, `proxy_port = ${proxyUrl.port}`);
            } catch (err) {
              reject(err);
            }
          }
          if (profile.headers !== '') {
            // 需上传headers文件
            await engineManager.uploadW3afHttpHeaderFile(profile.headers).then(res => {
              data = data.replace(/headers_file = /g, `headers_file = ${res.data.filePath}`);
            }).catch(err => {
              reject(err);
            });
          }
          if (profile.policies) {
            const policies = profile.policies.split('|').map(item => item.trim());
            const policyArr = [];
            for (const policy of policies) {
              if (policy in W3afChecks) {
                policyArr.push(...W3afChecks[policy]);
              }
            }
            let appendStr = '';
            Array.from(new Set(policyArr)).forEach(item => {
              appendStr += W3afChecks.ALL_CHECKS[item] + '\n';
            });
            data = data + appendStr;
          }

          this.#profile = data;
          // console.log(this.#profile);
          resolve();
        }
      });
    });
  };

  /**
   * @description 获得运行状态
   * @returns {Promise<{scanId: null}>}
   */
  getStatus = async () => {
    if (this.#status.status === 'Stopped') {
      // 扫描未开始
      return {
        scanId: null
      };
    } else {
      // 扫描已开始，状态未知
      const w3afStatus = await this.#getScanStatus(this.#status.scanId).then(res => res.data);
      if (w3afStatus.status === 'Stopped') {
        // 扫描正好结束
        this.#status.status = 'Stopped';
        return {
          scanId: null
        };
      } else {
        // 扫描仍在运行中
        const [urlCount, vulnCount] = await Promise.all([
          this.#getScanUrls(this.#status.scanId),
          this.#getScanVulns(this.#status.scanId)
        ]).then(res => res.map(item => item.data.items.length));
        // console.log(w3afStatus);
        return {
          scanId: this.#status.scanId,
          progress: 0,
          urlCount,
          vulnCount
        };
      }
    }
  };

  /**
   * @description 启动扫描
   * @param url<String>
   * @returns {Promise<void>}
   */
  startScan = async (url) => {
    // if (this.#status.status !== 'Stopped') {
    //   // throw new Error('W3af扫描正在进行中，无法开启新任务');
    // } else {
    await this.clearScan();
    this.#status.scanId = await this.#startNewScan(url, this.#profile).then(res => res.data.id) ?? -1;
    this.#status.status = 'Running';
    return this.#status.scanId;
    // }
  };

  /**
   * @description 停止扫描
   * @returns {Promise<void>}
   */
  stopScan = async () => {
    if (this.#status.status === 'Stopped') {
      // 已经停止扫描的情况下调用此函数，并不报错
      return;
    } else {
      await this.#stopRunningScan(this.#status.scanId);
    }
    this.#status.status = 'Stopped';
  };

  /**
   * @description 获得实时日志
   * @returns {Promise<string>}
   */
  getLogs = async () => {
    // TODO: 获得实时日志
  };

  /**
   * @description 获得扫描结果
   * @returns {Promise<Object>}
   */
  getResult = async () => {
    const [urlList, vulnList] = await Promise.all([
      this.getScanRequests(this.#status.scanId),
      this.#getScanVulns(this.#status.scanId)
    ]).then(res => res.map(item => item.data.items));

    const urls = urlList.map(itemB64 => {
      const item = Buffer.from(itemB64, 'base64').toString();
      const [method, url] = item.split(' ');
      // console.log(item);
      return {
        url,
        method,
        data: item,
        resourceType: 'static'
      };
    });

    const vulns = [];
    await Promise.allSettled(vulnList.map(v => {
      return new Promise((resolve, reject) => {
        this.#getScanVulnDetail(v.href).then(res => {
          const vuln = res.data;
          this.#getScanVulnTrafficDetail(vuln?.traffic_hrefs[0]).then(res => {
            const traffic = res.data;
            vulns.push({
              cwe: vuln?.cwe_ids ? vuln?.cwe_ids[0] : -1,
              name: vuln?.name,
              href: vuln?.url,
              level: vuln?.severity?.toLowerCase() ?? 'unknown',
              engine: 'w3af',
              information: {
                description: vuln?.desc ?? 'none',
                request: (Buffer.from(traffic.request, 'base64')?.toString() ?? '').trim(),
                response: (Buffer.from(traffic.response, 'base64')?.toString() ?? '').trim()
              }
            });
            resolve();
          }).catch(err => {
            reject(err);
          });
        }).catch(err => {
          reject(err);
        });
      });
    }));

    return {
      urls,
      vulns
    };
  };

  /**
   * @description 初始化API客户端
   * @returns {Promise<void>}
   */
  initClient = async () => {
    // TODO: 初始化API客户端
  };

  /**
   * @description 清除W3af扫描记录
   * @returns {Promise<void>}
   */
  clearScan = async () => {
    // 清除W3af扫描记录
    await this.#getScans().then(res =>
      res.data.items.map(item => item)
    ).then(async item => {
      await Promise.all(item.map(item => item.status === 'Running' ? this.#stopRunningScan(item.id) : null));
      await Promise.all(item.map(item => this.#deleteScan(item.id)));
    });
  };
}

const w3afAPIClient = new W3afAPIClient();

/* 用于测试 */
const runTest = async () => {
  // await w3afAPIClient.clearScan();
  // await w3afAPIClient.setProfile(null);
  // const thisScanId = await w3afAPIClient.startScan('http://testphp.vulnweb.com');
  // console.log(thisScanId);
  // setTimeout(async () => {
  //   console.log(await w3afAPIClient.getStatus());
  //   await w3afAPIClient.stopScan();
  //   console.log(await w3afAPIClient.getStatus());
  //   console.log(this.scanId);
  //   console.log(await w3afAPIClient.getResult());
  // }, 10000);
  const items = await w3afAPIClient.getScanRequests(7);
  items.data.items.map(item => {
    console.log(Buffer.from(item, 'base64').toString());
    return item;
  });
};

// runTest();

module.exports = { w3afAPIClient };
