from semantic_kernel import Kernel
from semantic_kernel.orchestration.context_variables import ContextVariables
from dotenv import dotenv_values

from log import logger
from planner.base import Plan, Planner
from retrieval import Retrieval

PROMPT = """
你是一个机器人，并且熟练掌握 Nmap 网络探测工具以及w3af，zaproxy，arachni这三款WEB漏洞检测工具
你的能力是根据你对这些工具的了解判断用户所希望你完成的意图[意图]能否通过这四款工具实现,注意仅仅判断用户的意图是否能通过这些工具实现，如果可以就在[输出]下方输出“1”，不可以则输出“0”，不输出除了“1”或“0”之外任何别的字符,完成后立刻停止输出。
下面是两个例子：
[意图]
你能帮我检查我的web服务上是否有栈溢出攻击的漏洞吗？
[输出]
0

[意图]
你能帮我检查我的web服务上是否有XSS攻击漏洞吗？
[输出]
1

例子完毕，下面开始真实场景应用
[意图]
{{$input}}
[输出]
"""


class CapChecker(Planner):

    def __init__(self,
                 kernel: Kernel,
                 skill_name: str,
                 reranker: Retrieval = None) -> None:
        super().__init__(kernel, skill_name, reranker)
        self.planner = kernel.create_semantic_function(PROMPT,
                                                       max_tokens=300,
                                                       temperature=0.8)

    async def create_plan_async(self, goal: str) -> Plan | None:
        logger.info(f": Capability check query input - {repr(goal)}")

        # Create the context for the planner
        context = ContextVariables()
        # Add the input to the context
        context["input"] = goal
        response = await self.planner.invoke_async(variables=context)
        config = dotenv_values(".env")
        model_load_type = config.get("GLOBAL__LLM_CALL_TYPE", None)
        if model_load_type == "local":
            result = response.result.split("[end of text]")[0].split("[输出]")[4].split("[意图]")[0]
        else:
            result = response.result
        logger.info(f": Capability check result - {repr(result)}")
        
        return Plan(prompt=PROMPT, goal=goal, generated_plan=result)

    async def execute_plan_async(self, plan: Plan) -> str:
        return plan.generated_plan
