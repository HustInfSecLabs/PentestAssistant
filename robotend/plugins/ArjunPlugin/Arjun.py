from semantic_kernel.skill_definition import (sk_function,
                                              sk_function_context_parameter)
from semantic_kernel.orchestration.sk_context import SKContext

'''
    命令行格式
Arjun can find query parameters for URL endpoints. If you don't get what that means, it's okay, read along.
Web applications use parameters (or queries) to accept user input, take the following example into consideration

http://api.example.com/v1/userinfo?id=751634589

This URL seems to load user information for a specific user id, but what if there exists a parameter named admin which 
when set to True makes the endpoint provide more information about the user?
This is what Arjun does, it finds valid HTTP parameters with a huge default dictionary of 25,890 parameter names.
The best part? It takes less than 10 seconds to go through this huge list while making just 50-60 requests to the target.
'''
class Arjun:
    # Function1: Use XSStrike to scan URLs ,测试get类请求请求存在的XSS漏洞，传入的url类似："http://192.168.26.138/xss.php?payload=1"
    @sk_function(
        description=
        "Run Arjun against a single URL.Arjun looks for GET method parameters by default. ",
        name="arjun_get_scan",
    )
    @sk_function_context_parameter(
        description="target url address with get request",
        name="target",
    )
    def xss_get_test(self, context: SKContext) -> str:
        print_str = f"arjun -u {context['target']}"
        return print_str

    # Function2: Use XSStrike to scan URLs ,测试post类请求存在的XSS漏洞，传入的url类似："http://example.com/search.php" --data "q=query"
    @sk_function(
        description=
        "Run Arjun against a single URL and Arjun looks for POST method parameters by using -m POST.",
        name="arjun_post_scan",
    )
    @sk_function_context_parameter(
        description="target url address",
        name="target",
    )
    @sk_function_context_parameter(
        description="Supplying POST data",
        name="postdata",
    )
    def xss_post_test(self, context: SKContext) -> str:
        print_str = f"xsstrike -u {context['target']} --data={context['postdata']}"
        return print_str

    # Function3:在URL路径中注入有效载荷，例如http://example.com/search/<payload>，可以使用--path选项。
    @sk_function(
        description=
        "Want to inject payloads in the URL path like http://example.com/search/<payload>, you can do that with --path switch.",
        name="xss_urlpath_test",
    )
    @sk_function_context_parameter(
        description="target url address with injected payload in url path",
        name="target",
    )
    def xss_urlpath_test(self, context: SKContext) -> str:
        print_str = f"xsstrike -u {context['target']} --path"
        return print_str

    #   Function4: 爬虫，爬取url下类似的目标。从目标网页开始爬行，寻找目标并测试它们，默认的爬取深度为2
    @sk_function(
        description=
        "Start crawling from the target webpage for targets and test them.",
        name="xss_craw_test",
    )
    @sk_function_context_parameter(
        description="target crawl url address",
        name="target",
    )

    def xss_craw_test(self,context: SKContext) -> str:
        print_str = f"xsstrike -u {context['target']} --crawl"
        return print_str

    # Function5:模糊测试，在xss漏洞利用方面进行模糊参数测试绕过waf eg：python xsstrike.py -u "http://example.com/search.php?q=query" --fuzzer
    @sk_function(
        description=
        " The fuzzer is meant to test filters and Web Application Firewalls. It is painfully slow because it sends randomly* delay requests and the delay can be up to 30 seconds. ",
        name="xss_fuzzing_test",
    )
    @sk_function_context_parameter(
        description="target url address",
        name="target",
    )
    def xss_fuzzing_test(self, context: SKContext) -> str:
        print_str = f"xsstrike -u {context['target']} --fuzzer "
        return print_str

    # Function6: xss盲注,与功能4配合使用，在爬虫的基础上，将您在core/config.py中定义的盲XSS有效载荷注入到每个HTML表单的每个参数中。python xsstrike.py -u http://example.com/page.php?q=query --crawl --blind
    @sk_function(
        description=
        " Using this option while crawling will make XSStrike inject your blind XSS payload defined in core/config.py to be injected to every parameter of every HTML form.",
        name="xss_crawl_blind",
    )
    @sk_function_context_parameter(
        description="target url address",
        name="target",
    )
    def xss_crawl_blind(self,context: SKContext) -> str:
        print_str = f"xsstrike -u {context['target']} --crawl --blind"
        return print_str

    # Function7: Payload Encoding,在功能1的基础上加强使用，把xss通过get请求注入的payload进行encode仅支持base64编码,python xsstrike.py -u "http://example.com/page.php?q=query" -e base64
    @sk_function(
        description="XSStrike can encode payloads on demand but only base64 encode method is available",
        name="xss_get_base64",
    )
    @sk_function_context_parameter(
        description="target url address",
        name="target",
    )
    def xss_get_base64(self,context: SKContext) -> str:
        print_str = f"xsstrike -u {context['target']} -e base64"
        return print_str