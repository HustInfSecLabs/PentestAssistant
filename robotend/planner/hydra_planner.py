"""A basic JSON-based planner for the Python Semantic Kernel"""
import json
import regex
import subprocess
from typing import Tuple, Optional
from dotenv import dotenv_values

from semantic_kernel.kernel import Kernel
from semantic_kernel.orchestration.context_variables import ContextVariables

from bot import ReturnCodeEnum
from log import logger
from retrieval import Retrieval
from planner.base import Plan, Planner

PROMPT = """You are a planner for the Semantic Kernel.
Your job is to create a properly formatted JSON plan step by step, to satisfy the goal given.
Create a list of subtasks based off the [GOAL] provided.
Each subtask must be from within the [AVAILABLE FUNCTIONS] list. Do not use any functions that are not in the list.
Base your decisions on which function to use from the description and the name of the function, only one function can be given.
Sometimes, a function may take arguments. Provide them if necessary.
The plan should be as short as possible.
For example:

[AVAILABLE FUNCTIONS]
Hydra.burstRDP
description: 对目标地址进行RDP协议的账户密码爆破.
args:
- url: Target ip or hostname


[GOAL]
"请帮我爆破baidu.com的RDP协议的账户密码"

[OUTPUT]
{
    "function": "Hydra.burstRDP",
    "args": {
        "url": "baidu.com"
    }
}

[AVAILABLE FUNCTIONS]
{{$available_functions}}

[GOAL]
{{$goal}}

[OUTPUT]
"""

PROMPT_FOR_COMPLETION = """根据您的需求，执行该函数

{function_string}

但是根据您提供的信息，无法补全目标参数，请您根据已生成的参数列表，补全剩余参数信息
已生成参数列表：
{function_args}

要求每行输入一个参数，并用冒号分割参数名和参数值，如 ip: baidu.com
"""


class HydraPlanner(Planner):
    """
    Basic JSON-based planner for the Semantic Kernel.
    """

    def __init__(self,
                 kernel: Kernel,
                 skill_name: str,
                 reranker: Retrieval = None) -> None:
        super().__init__(kernel, skill_name, reranker)
        self.planner = self.kernel.create_semantic_function(PROMPT,
                                                            max_tokens=500,
                                                            temperature=0.8)

    def _create_available_functions_string(self, goal: str) -> str:
        """
        Given an instance of the Kernel, create the [AVAILABLE FUNCTIONS]
        string for the prompt.
        """
        functions = self.kernel.skills.get_functions_view().native_functions.get(self.skill_name)

        available_functions_string = ""
        for function in functions:

            available_functions_string += f"{self.skill_name}.{function.name}\n"
            available_functions_string += f"description: {function.description}\n"
            available_functions_string += "args:\n"

            # Add the parameters for each function
            for arg in function.parameters:
                if not arg.description:
                    param_description = ""
                else:
                    param_description = arg.description
                available_functions_string += ("- " + arg.name + ": " + param_description + "\n")
            available_functions_string += "\n"

        logger.info(
            ": 可供选择的API - {available_functions_string}".format(available_functions_string=available_functions_string))
        return available_functions_string

    def _check_generated_plan(
        self,
        generated_plan: str,
    ) -> Tuple[int, Optional[dict]]:
        """
        check if generate_plan have json format plan, and set default
        value for args
        """
        if len(generated_plan) == 0:
            return ReturnCodeEnum.CREATE_FUNCTION_FORMAT_FAIL, ""
        config = dotenv_values(".env")
        model_load_type = config.get("GLOBAL__LLM_CALL_TYPE", None)
        # use api
        json_regex = r"\{(?:[^{}]|(?R))*\}"
        if model_load_type == "api":
            generated_plan_string = regex.findall(json_regex, generated_plan)[0]
        # check if these is json plan
        else:
            generated_plan_string = regex.findall(json_regex, generated_plan)[1]
        # check json format, name, and param
        try:
            generated_plan_json = json.loads(generated_plan_string)
            skill_name, function_name = generated_plan_json["function"].split(".")
            if not self.kernel.skills.has_native_function(skill_name, function_name):
                logger.error(": Check Generated Plan: plan does not have correct function name - {plan}".format(
                    plan=repr(generated_plan)))
                return ReturnCodeEnum.CREATE_FUNCTION_NAME_FAIL, generated_plan_json

            for arg in self.kernel.skills.get_native_function(skill_name, function_name).parameters:
                if arg.name not in generated_plan_json["args"]:
                    logger.error(": Check Generated Plan: plan does not have correct function params - {plan}".format(
                        plan=repr(generated_plan)))
                    return ReturnCodeEnum.CREATE_FUNCTION_PARAM_FAIL, generated_plan_json

                # add default value
                if arg.default_value != "" and arg.name not in generated_plan_json["args"]:
                    generated_plan_json["args"][arg.name] = arg.default_value
        except:
            logger.error(
                ": Check Generated Plan: plan does not have correct format - {plan}".format(plan=repr(generated_plan)))
            return ReturnCodeEnum.CREATE_FUNCTION_FORMAT_FAIL, generated_plan_json

        return 0, generated_plan_json

    def create_completion_prompt(self, plan: Plan) -> str:
        generated_plan_json = plan.generated_plan
        skill_name, function_name = generated_plan_json["function"].split(".")
        function = self.kernel.skills.get_native_function(
            skill_name, function_name)

        function_string = ""
        function_string += f"{skill_name}.{function_name}\n"
        function_string += f"description: f{function.description}\n"
        function_string += "args:"

        for arg in function.parameters:
            if not arg.description:
                param_description = ""
            else:
                param_description = arg.description
            function_string += ("\n" + "- " + arg.name + ": " +
                                param_description)

        function_args = ""
        for arg_name, arg_value in generated_plan_json["args"].items():
            function_args += f"\n{arg_name}: {arg_value}"

        return PROMPT_FOR_COMPLETION.format(function_string=function_string,
                                            function_args=function_args)

    async def create_plan_async(
        self,
        goal: str,
    ) -> Tuple[int, Plan]:
        """
        Creates a plan for the given goal based off the functions that
        are available in the kernel.
        """
        logger.info(f": Hydra Planner Goal - {goal}")

        # Create the semantic function for the planner with the given prompt
        available_functions_string = self._create_available_functions_string(goal)

        # Create the context for the planner
        context = ContextVariables()
        # Add the goal to the context
        context["goal"] = goal
        context["available_functions"] = available_functions_string
        generated_plan = await self.planner.invoke_async(variables=context)

        logger.info(f"LLM output: {repr(generated_plan.result)}")

        return_code, generated_plan_json = self._check_generated_plan(
            generated_plan.result)
        if return_code == 0:
            return 0, Plan(prompt=PROMPT,
                           goal=goal,
                           generated_plan=generated_plan_json)

        return return_code, Plan(prompt=PROMPT,
                                 goal=goal,
                                 generated_plan=generated_plan_json)

    async def create_plan_for_completion_async(
        self,
        goal: str,
        plan: Plan,
    ) -> Tuple[int, Plan]:
        """
        according to the completion for last plan by the user, generate new plan
        the format of `goal` is:
        arg_name1: arg_value1
        arg_name2: arg_value2
        """
        logger.info(f": Hydra Planner User Completion - {goal}")

        try:
            generated_plan_json = plan.generated_plan
            for arg_string in goal.strip().split("\n"):
                arg_name, arg_value = arg_string.split(":")
                generated_plan_json["args"][arg_name] = arg_value.strip()
        except:
            logger.error(f": Completion Plan Fail - {repr(goal)}")
            return ReturnCodeEnum.COMPLETION_FUNCTION_FAIL, None

        return 0, Plan(plan.prompt, plan.goal, generated_plan_json)

    async def exec_hydra_async(self, cmd: str) -> str:
        process = subprocess.run(cmd.split(" "), capture_output=True)

        if process.returncode != 0:
            logger.warn(
                f": hydra call error - {repr(cmd)} - {repr(process.stderr.decode())}"
            )

        return process.stdout.decode()

    async def execute_plan_async(self, plan: Plan, exec: bool) -> str:
        """
        Given a plan, execute each of the functions within the plan
        from start to finish and output the result.
        """
        logger.info(": Hydra Planner Plan -: {plan}".format(
            plan=repr(plan.generated_plan)))
        generated_plan_json = plan.generated_plan

        context = ContextVariables()
        for arg_name, arg_value in generated_plan_json["args"].items():
            context[arg_name] = arg_value

        skill_name, function_name = generated_plan_json["function"].split(".")
        sk_function = self.kernel.skills.get_native_function(
            skill_name, function_name)
        output = await sk_function.invoke_async(variables=context)
        result = output.result

        if exec:
            result = await self.exec_hydra_async(result)

        return result
