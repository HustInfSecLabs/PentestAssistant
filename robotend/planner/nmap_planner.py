"""A basic JSON-based planner for the Python Semantic Kernel"""
import json
import regex
import subprocess
from typing import Tuple, Optional
from dotenv import dotenv_values

from semantic_kernel.kernel import Kernel
from semantic_kernel.orchestration.context_variables import ContextVariables

from bot import ReturnCodeEnum
from log import logger
from retrieval import Retrieval
from planner.base import Plan, Planner

PROMPT = """You are a planner for the Semantic Kernel.
Your job is to create a properly formatted JSON plan step by step, to satisfy the goal given.
Create a list of subtasks based off the [GOAL] provided.
Each subtask must be from within the [AVAILABLE FUNCTIONS] list. Do not use any functions that are not in the list.
Base your decisions on which function to use from the description and the name of the function, only one function can be given.
Sometimes, a function may take arguments. Provide them if necessary.
The plan should be as short as possible.
For example:

[AVAILABLE FUNCTIONS]
Nmap.asn_query
description: Maps IP addresses to autonomous system (AS) numbers.
args:
- dns: The address of a recursive nameserver to use (optional).
- target: Target ip or hostname

Nmap.dhcp_discover
description: Sends a DHCPINFORM request to a host on UDP port 67 to obtain all the local configuration parameters without allocating a new address
args:
- target: Target ip or hostname

Nmap.cups_info
description: Lists printers managed by the CUPS printing service.
args:
- port: target port
- ip: Target ip


[GOAL]
"请帮我获取wwww.baidu.com地址的DHCP服务信息"

[OUTPUT]
{
    "function": "Nmap.dhcp_discover",
    "args": {
        "target": "192.167.0.2"
    }
}

[AVAILABLE FUNCTIONS]
{{$available_functions}}

[GOAL]
{{$goal}}

[OUTPUT]
"""

FORMAT_PROMPT_LOG = """
You are a planner for the Semantic Kernel.
Your job is to create a properly formatted JSON plan step by step, to satisfy the goal given.
Create a list of subtasks based off the [GOAL] provided.
Each subtask must be from within the [AVAILABLE FUNCTIONS] list. Do not use any functions that are not in the list.
Base your decisions on which function to use from the description and the name of the function, only one function can be given.
Sometimes, a function may take arguments. Provide them if necessary.
The plan should be as short as possible.
For example:

[AVAILABLE FUNCTIONS]
Nmap.asn_query
description: Maps IP addresses to autonomous system (AS) numbers.
args:
- dns: The address of a recursive nameserver to use (optional).
- target: Target ip or hostname

Nmap.dhcp_discover
description: Sends a DHCPINFORM request to a host on UDP port 67 to obtain all the local configuration parameters without allocating a new address
args:
- target: Target ip or hostname

Nmap.cups_info
description: Lists printers managed by the CUPS printing service.
args:
- port: target port
- ip: Target ip


[GOAL]
"请帮我获取wwww.baidu.com地址的DHCP服务信息"

[OUTPUT]
{{
    "function": "Nmap.dhcp_discover",
    "args": {{
        "target": "192.167.0.2"
    }}
}}

[AVAILABLE FUNCTIONS]
{available_functions}

[GOAL]
{goal}

[OUTPUT]
"""

PROMPT_FOR_COMPLETION = """根据您的需求，执行该函数

{function_string}

但是根据您提供的信息，无法补全目标参数，请您根据已生成的参数列表，补全剩余参数信息
已生成参数列表：
{function_args}

要求每行输入一个参数，并用冒号分割参数名和参数值，如 ip: 192.168.0.1
"""


class NmapPlanner(Planner):
    """
    Basic JSON-based planner for the Semantic Kernel.
    """

    def __init__(self, kernel: Kernel, skill_name: str, reranker: Retrieval = None) -> None:
        super().__init__(kernel, skill_name, reranker)
        self.planner = self.kernel.create_semantic_function(PROMPT, max_tokens=500, temperature=0.8)

    def _create_available_functions_string(self, goal: str) -> str:
        """
        Given an instance of the Kernel, create the [AVAILABLE FUNCTIONS]
        string for the prompt.
        """
        functions = self.kernel.skills.get_functions_view().native_functions.get(self.skill_name)
        functions_description = []
        for function in functions:
            functions_description.append(function.description)

        topk_descriptions = self.reranker.compute_topk(goal, functions_description, top_k=10)

        # Create the [AVAILABLE FUNCTIONS] section of the prompt
        available_functions_string = ""
        i = 0
        for function in functions:
            i += 1
            if function.description not in topk_descriptions:
                continue

            available_functions_string += f"{self.skill_name}.{function.name}\n"
            available_functions_string += f"description: {function.description}\n"
            available_functions_string += "args:\n"

            # Add the parameters for each function
            for arg in function.parameters:
                if not arg.description:
                    param_description = ""
                else:
                    param_description = arg.description
                available_functions_string += ("- " + arg.name + ": " + param_description + "\n")
            available_functions_string += "\n"
        logger.info("总API个数为{}个，过滤API个数{}个,剩余可供选择的API个数{}个".format(i, i - 10, 10))
        logger.info(
            ": 可供选择的API - {available_functions_string}".format(available_functions_string=available_functions_string))
        return available_functions_string

    def _check_generated_plan(
        self,
        generated_plan: str,
    ) -> Tuple[int, Optional[dict]]:
        """
        check if generate_plan have json format plan, and set default
        value for args
        """
        if len(generated_plan) == 0:
            return ReturnCodeEnum.CREATE_FUNCTION_FORMAT_FAIL, ""
        config = dotenv_values(".env")
        model_load_type = config.get("GLOBAL__LLM_CALL_TYPE", None)
        # use api
        json_regex = r"\{(?:[^{}]|(?R))*\}"
        if model_load_type == "api":
            generated_plan_string = regex.findall(json_regex, generated_plan)[0]
        # check if these is json plan
        else:
            generated_plan_string = regex.findall(json_regex, generated_plan)[1]
        # check json format, name, and param
        try:
            generated_plan_json = json.loads(generated_plan_string)
            skill_name, function_name = generated_plan_json["function"].split(".")
            if not self.kernel.skills.has_native_function(skill_name, function_name):
                logger.error(": Check Generated Plan: plan does not have correct function name - {plan}".format(
                    plan=repr(generated_plan)))
                return ReturnCodeEnum.CREATE_FUNCTION_NAME_FAIL, generated_plan_json

            for arg in self.kernel.skills.get_native_function(skill_name, function_name).parameters:
                if arg.name not in generated_plan_json["args"]:
                    logger.error(": Check Generated Plan: plan does not have correct function params - {plan}".format(
                        plan=repr(generated_plan)))
                    return ReturnCodeEnum.CREATE_FUNCTION_PARAM_FAIL, generated_plan_json

                # add default value
                if arg.default_value != "" and arg.name not in generated_plan_json["args"]:
                    generated_plan_json["args"][arg.name] = arg.default_value
        except:
            logger.error(
                ": Check Generated Plan: plan does not have correct format - {plan}".format(plan=repr(generated_plan)))
            return ReturnCodeEnum.CREATE_FUNCTION_FORMAT_FAIL, generated_plan_json

        return 0, generated_plan_json

    def create_completion_prompt(self, plan: Plan) -> str:
        generated_plan_json = plan.generated_plan
        skill_name, function_name = generated_plan_json["function"].split(".")
        function = self.kernel.skills.get_native_function(skill_name, function_name)

        function_string = ""
        function_string += f"{skill_name}.{function_name}\n"
        function_string += f"description: {function.description}\n"
        function_string += "args:"

        for arg in function.parameters:
            if not arg.description:
                param_description = ""
            else:
                param_description = arg.description
            function_string += ("\n" + "- " + arg.name + ": " + param_description)

        function_args = ""
        for arg_name, arg_value in generated_plan_json["args"].items():
            function_args += f"\n{arg_name}: {arg_value}"

        return PROMPT_FOR_COMPLETION.format(function_string=function_string, function_args=function_args)

    async def create_plan_async(
        self,
        goal: str,
    ) -> Tuple[int, Plan]:
        """
        Creates a plan for the given goal based off the functions that
        are available in the kernel.
        """
        logger.info(f": NMAP工具目标 - {goal}")

        # Create the semantic function for the planner with the given prompt
        available_functions_string = self._create_available_functions_string(goal)

        # Create the context for the planner
        context = ContextVariables()
        # Add the goal to the context
        context["goal"] = goal
        context["available_functions"] = available_functions_string
        generated_plan = await self.planner.invoke_async(variables=context)
        # print("generated_plan:", generated_plan)
        formatted_prompt = FORMAT_PROMPT_LOG.format(available_functions=available_functions_string, goal=goal)
        logger.info(f"大模型输入: {formatted_prompt}")
        logger.info(f"大模型输出: {generated_plan.result}")
        return_code, generated_plan_json = self._check_generated_plan(generated_plan.result)
        if return_code == 0:
            return 0, Plan(prompt=PROMPT, goal=goal, generated_plan=generated_plan_json)

        return return_code, Plan(prompt=PROMPT, goal=goal, generated_plan=generated_plan_json)

    async def create_plan_for_completion_async(
        self,
        goal: str,
        plan: Plan,
    ) -> Tuple[int, Plan]:
        """
        according to the completion for last plan by the user, generate new plan
        the format of `goal` is:
        arg_name1: arg_value1
        arg_name2: arg_value2
        """
        logger.info(f": Nmap Planner User Completion - {goal}")

        try:
            generated_plan_json = plan.generated_plan
            for arg_string in goal.strip().split("\n"):
                arg_name, arg_value = arg_string.split(":")
                generated_plan_json["args"][arg_name] = arg_value.strip()
        except:
            logger.error(f": Completion Plan Fail - {repr(goal)}")
            return ReturnCodeEnum.COMPLETION_FUNCTION_FAIL, None

        return 0, Plan(plan.prompt, plan.goal, generated_plan_json)

    async def exec_nmap_async(self, cmd: str) -> str:
        process = subprocess.run(cmd.split(" "), capture_output=True)

        if process.returncode != 0:
            logger.warn(f": nmap call error - {repr(cmd)} - {repr(process.stderr.decode())}")

        return process.stdout.decode("utf-8", "ignore")

    async def execute_plan_async(self, plan: Plan, exec: bool) -> str:
        """
        Given a plan, execute each of the functions within the plan
        from start to finish and output the result.
        """
        logger.info(": NMAP工具调用计划 -: {plan}".format(plan=repr(plan.generated_plan)))
        generated_plan_json = plan.generated_plan

        context = ContextVariables()
        for arg_name, arg_value in generated_plan_json["args"].items():
            context[arg_name] = arg_value

        skill_name, function_name = generated_plan_json["function"].split(".")
        sk_function = self.kernel.skills.get_native_function(skill_name, function_name)
        output = await sk_function.invoke_async(variables=context)
        result = output.result

        if exec:
            result = await self.exec_nmap_async(result)

        return result
